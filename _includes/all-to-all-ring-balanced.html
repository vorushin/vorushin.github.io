<style>
    .all-to-all-balanced-viz {
        font-family: 'IBM Plex Sans', sans-serif;
        background: var(--bg, #fafaf9);
        color: var(--fg, #1c1917);
        width: 100%;
        margin: 2rem auto;
    }

    .all-to-all-balanced-viz .canvas-wrap {
        position: relative;
        width: 100%;
        border: 1px solid #d6d3d1;
        border-radius: 10px;
        overflow: hidden;
        background: #fafaf9;
    }

    .all-to-all-balanced-viz canvas {
        display: block;
        width: 100%;
        height: auto;
    }

    .all-to-all-balanced-viz .controls {
        position: absolute;
        bottom: 0.75rem;
        right: 0.75rem;
        display: flex;
        align-items: center;
        gap: 0.4rem;
    }

    .all-to-all-balanced-viz button {
        font-family: 'IBM Plex Mono', monospace;
        font-size: 0.78rem;
        font-weight: 500;
        padding: 0.4rem 0.85rem;
        border: 1px solid #d6d3d1;
        border-radius: 6px;
        background: white;
        color: #1c1917;
        cursor: pointer;
        transition: all 0.15s;
        user-select: none;
    }

    .all-to-all-balanced-viz button:hover {
        background: #f5f5f4;
        border-color: #a8a29e;
    }

    .all-to-all-balanced-viz button:active {
        background: #e7e5e4;
    }

    .all-to-all-balanced-viz button.active {
        background: #1c1917;
        color: white;
        border-color: #1c1917;
    }



</style>

<div class="all-to-all-balanced-viz">
    <div class="canvas-wrap">
        <canvas id="allToAllBalancedCanvas"></canvas>
        <div class="controls">
            <button id="allToAllBalancedPlayBtn" class="active">⏸ Pause</button>
            <button id="allToAllBalancedResetBtn">↺ Reset</button>
        </div>
    </div>
</div>

<script>
    (function () {
        // ─── Constants ───
        const N = 8;
        const COLORS = [
            '#dc2626', '#ea580c', '#ca8a04', '#16a34a',
            '#0891b2', '#2563eb', '#7c3aed', '#c026d3'
        ];

        const canvas = document.getElementById('allToAllBalancedCanvas');
        const ctx = canvas.getContext('2d');
        const DPR = 2;
        const CW = 720 * DPR;
        const CH = 680 * DPR;
        canvas.width = CW;
        canvas.height = CH;

        const S = DPR;
        const CX = CW / 2;
        const CY = CH / 2 + 5 * S;
        const RING_R = 250 * S;
        const CELL = 10 * S;
        const GRID = N * CELL;
        const PAD = 8 * S;
        const BOX = GRID + PAD * 2;
        const BLK = CELL - 1.5 * S;
        const FLY_BLK = BLK;

        // ─── TPU positions ───
        function tpuAngle(i) { return -Math.PI / 2 + i * (2 * Math.PI / N); }
        function tpuXY(i) {
            const a = tpuAngle(i);
            return [CX + RING_R * Math.cos(a), CY + RING_R * Math.sin(a)];
        }

        function cellXY(tpu, row, col) {
            const [tx, ty] = tpuXY(tpu);
            return [
                tx - GRID / 2 + col * CELL + (CELL - BLK) / 2,
                ty - GRID / 2 + row * CELL + (CELL - BLK) / 2
            ];
        }

        // ─── Precompute simulation ───
        // Balanced routing: even-source TPUs break ties CW, odd-source CCW
        const STEPS = 5;
        const st = [];
        st[0] = Array.from({ length: N }, (_, r) => Array(N).fill(r));
        for (let s = 1; s < STEPS; s++) {
            st[s] = Array.from({ length: N }, (_, r) =>
                Array.from({ length: N }, (_, c) => {
                    const p = st[s - 1][r][c];
                    if (p === c) return p;
                    const cw = (c - p + N) % N;
                    const ccw = (p - c + N) % N;
                    // Alternate tie-breaking: even source TPUs → CW, odd → CCW
                    return (r % 2 === 0 ? cw <= ccw : cw < ccw) ? (p + 1) % N : (p - 1 + N) % N;
                })
            );
        }

        // transitions per step
        const trans = [];
        for (let s = 0; s < STEPS - 1; s++) {
            const mv = [];
            for (let r = 0; r < N; r++)
                for (let c = 0; c < N; c++) {
                    const fr = st[s][r][c], to = st[s + 1][r][c];
                    if (fr !== to) mv.push({ r, c, fr, to, dir: (fr + 1) % N === to ? 1 : -1 });
                }
            trans.push(mv);
        }

        // Group moves by (from→to) for cluster drawing
        function groupMoves(s) {
            const g = {};
            for (const m of trans[s]) {
                const k = `${m.fr}_${m.to}`;
                (g[k] ||= []).push(m);
            }
            return g;
        }

        // Link traffic: link i = edge tpu_i ↔ tpu_(i+1)%N, split by direction
        const linkTrafficCW = [];
        const linkTrafficCCW = [];
        for (let s = 0; s < STEPS - 1; s++) {
            const cw = new Array(N).fill(0);
            const ccw = new Array(N).fill(0);
            for (const m of trans[s]) {
                if (m.dir === 1) cw[m.fr]++;
                else ccw[m.to]++;
            }
            linkTrafficCW.push(cw);
            linkTrafficCCW.push(ccw);
        }

        // ─── Totals for finish screen ───
        const totalMoved = trans.reduce((sum, t) => sum + t.length, 0);
        const totalPerLinkCW = linkTrafficCW.reduce((sum, t) => sum + t[0], 0);
        const totalPerLinkCCW = linkTrafficCCW.reduce((sum, t) => sum + t[0], 0);
        const totalPerLink = totalPerLinkCW + totalPerLinkCCW;

        // ─── Anim state ───
        let curStep = 0;
        let inTrans = false;
        let tProg = 0;
        let holdT = 0;
        const HOLD_MS = 1800;
        const TRANS_MS = 5000;
        let playing = true;
        let speed = 2.0;
        let lastTS = 0;

        // ─── Easing ───
        function easeIO(t) { return t < .5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }

        // ─── Drawing ───
        function rr(x, y, w, h, r, fill, stroke, lw) {
            ctx.beginPath(); ctx.roundRect(x, y, w, h, r);
            if (fill) { ctx.fillStyle = fill; ctx.fill(); }
            if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lw || S; ctx.stroke(); }
        }

        function drawBlk(x, y, sz, color, alpha) {
            ctx.save(); ctx.globalAlpha = alpha;
            rr(x, y, sz, sz, 2.5 * S, color);
            ctx.globalAlpha = alpha * 0.35;
            ctx.fillStyle = '#fff';
            ctx.fillRect(x + S, y + S, sz - 2 * S, 2 * S);
            ctx.restore();
        }

        function arrowHead(x, y, nx, ny, sz) {
            const px = -ny, py = nx;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - nx * sz + px * sz * .45, y - ny * sz + py * sz * .45);
            ctx.lineTo(x - nx * sz - px * sz * .45, y - ny * sz - py * sz * .45);
            ctx.closePath(); ctx.fill();
        }

        // ─── Ring links + traffic ───
        function drawLinks() {
            for (let i = 0; i < N; i++) {
                const j = (i + 1) % N;
                const [ax, ay] = tpuXY(i);
                const [bx, by] = tpuXY(j);
                const dx = bx - ax, dy = by - ay;
                const len = Math.hypot(dx, dy);
                const nx = dx / len, ny = dy / len;
                const margin = BOX / 2 + 8 * S;
                const x1 = ax + nx * margin, y1 = ay + ny * margin;
                const x2 = bx - nx * margin, y2 = by - ny * margin;

                ctx.strokeStyle = '#d6d3d1';
                ctx.lineWidth = 2.5 * S;
                ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();

                ctx.fillStyle = '#b8b3ae';
                arrowHead(x2, y2, nx, ny, 5 * S);
                arrowHead(x1, y1, -nx, -ny, 5 * S);

                // Traffic pill — show during animation AND hold after
                const hIdx = activeHopIdx();
                if (hIdx >= 0 && hIdx < linkTrafficCW.length) {
                    const cwCount = linkTrafficCW[hIdx][i];
                    const ccwCount = linkTrafficCCW[hIdx][i];
                    const count = cwCount + ccwCount;
                    if (count > 0) {
                        const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
                        const ox = mx - CX, oy = my - CY;
                        const ol = Math.hypot(ox, oy) || 1;
                        const offD = 20 * S;
                        const lx = mx + (ox / ol) * offD;
                        const ly = my + (oy / ol) * offD;

                        const fadeIn = inTrans ? Math.min(tProg * 5, 1) : 1;
                        ctx.save(); ctx.globalAlpha = fadeIn;

                        ctx.font = `600 ${14 * S}px "IBM Plex Mono", monospace`;
                        const label = `${cwCount} + ${ccwCount}`;
                        const tw = ctx.measureText(label).width;
                        const gap = 3 * S;
                        const totalW = tw + gap + BLK;
                        ctx.fillStyle = '#57534e';
                        ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                        ctx.fillText(label, lx - totalW / 2, ly);
                        drawBlk(lx - totalW / 2 + tw + gap, ly - BLK / 2, BLK, '#78716c', 0.85 * fadeIn);
                        ctx.restore();
                    }
                }
            }
        }

        // ─── Draw one TPU ───
        function drawTPU(idx, blocks) {
            const [tx, ty] = tpuXY(idx);
            const bx = tx - BOX / 2, by = ty - BOX / 2;

            rr(bx + 2 * S, by + 3 * S, BOX, BOX, 7 * S, 'rgba(0,0,0,0.06)');
            rr(bx, by, BOX, BOX, 7 * S, '#f5f5f4', '#d6d3d1', 1.5 * S);

            ctx.save();
            ctx.beginPath(); ctx.roundRect(bx, by, BOX, BOX, 7 * S); ctx.clip();
            ctx.strokeStyle = '#e7e5e4'; ctx.lineWidth = .6 * S;
            for (let k = -BOX; k < BOX * 2; k += 5 * S) {
                ctx.beginPath(); ctx.moveTo(bx + k, by); ctx.lineTo(bx + k + BOX, by + BOX); ctx.stroke();
            }
            ctx.restore();

            const gx = tx - GRID / 2, gy = ty - GRID / 2;
            ctx.strokeStyle = 'rgba(0,0,0,0.05)'; ctx.lineWidth = .5 * S;
            for (let r = 0; r <= N; r++) {
                ctx.beginPath(); ctx.moveTo(gx, gy + r * CELL); ctx.lineTo(gx + GRID, gy + r * CELL); ctx.stroke();
            }
            for (let c = 0; c <= N; c++) {
                ctx.beginPath(); ctx.moveTo(gx + c * CELL, gy); ctx.lineTo(gx + c * CELL, gy + GRID); ctx.stroke();
            }

            for (const b of blocks) {
                const [cx, cy] = cellXY(idx, b.r, b.c);
                drawBlk(cx, cy, BLK, COLORS[b.r], 1);
            }

            ctx.font = `600 ${16 * S}px "IBM Plex Mono", monospace`;
            ctx.fillStyle = '#44403c'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
            ctx.fillText(idx.toString(), tx, by - 6 * S);
        }

        // ─── Flying clusters ───
        function drawFlying() {
            const et = easeIO(tProg);
            const groups = groupMoves(curStep);

            for (const key of Object.keys(groups)) {
                const arr = groups[key];
                const { fr, to } = arr[0];

                for (let i = 0; i < arr.length; i++) {
                    const m = arr[i];
                    // Start: source cell position on source TPU
                    const [sx, sy] = cellXY(fr, m.r, m.c);
                    // End: destination cell position on destination TPU
                    const [ex, ey] = cellXY(to, m.r, m.c);
                    const bx = sx + (ex - sx) * et;
                    const by = sy + (ey - sy) * et;
                    drawBlk(bx, by, FLY_BLK, COLORS[m.r], 0.95);
                }
            }
        }

        // ─── Header ───
        function drawHeader() {
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';

            if (curStep === 0 && !inTrans) {
                ctx.font = `700 ${26 * S}px "IBM Plex Sans", sans-serif`;
                ctx.fillStyle = '#1c1917';
                ctx.fillText('Start', CX, CY - 10 * S);
            } else if (curStep === STEPS - 1 && !inTrans) {
                ctx.font = `700 ${26 * S}px "IBM Plex Sans", sans-serif`;
                ctx.fillStyle = '#1c1917';
                ctx.fillText('Finish', CX, CY - 24 * S);
                ctx.font = `600 ${17 * S}px "IBM Plex Mono", monospace`;
                ctx.fillStyle = '#78716c';
                ctx.fillText(`${totalMoved} blocks moved total`, CX, CY + 10 * S);
                ctx.fillText(`${totalPerLinkCW} CW + ${totalPerLinkCCW} CCW = ${totalPerLink} per link`, CX, CY + 30 * S);
            } else {
                // Active hop — show during both animation AND hold after
                const hopIdx = inTrans ? curStep : curStep - 1; // index into trans[]
                const hopNum = hopIdx + 1;
                ctx.font = `700 ${26 * S}px "IBM Plex Sans", sans-serif`;
                ctx.fillStyle = '#1c1917';
                ctx.fillText(`Hop ${hopNum} of ${STEPS - 1}`, CX, CY - 24 * S);
                if (hopIdx >= 0 && hopIdx < trans.length) {
                    const cwPerLink = linkTrafficCW[hopIdx][0];
                    const ccwPerLink = linkTrafficCCW[hopIdx][0];
                    const moving = trans[hopIdx].length;
                    ctx.font = `600 ${17 * S}px "IBM Plex Mono", monospace`;
                    ctx.fillStyle = '#78716c';
                    ctx.fillText(`${moving} blocks in flight`, CX, CY + 30 * S);
                    ctx.fillText(`${cwPerLink} CW + ${ccwPerLink} CCW = ${cwPerLink + ccwPerLink} per link`, CX, CY + 50 * S);
                }
            }
        }

        // Helper: get the active hop index for link traffic display (or -1)
        function activeHopIdx() {
            if (curStep === 0 && !inTrans) return -1;
            if (curStep === STEPS - 1 && !inTrans) return -1;
            return inTrans ? curStep : curStep - 1;
        }

        // ─── Main loop ───
        function tick(ts) {
            const dt = lastTS ? (ts - lastTS) : 16;
            lastTS = ts;

            if (playing) {
                if (!inTrans) {
                    holdT += dt * speed;
                    if (holdT >= HOLD_MS && curStep < STEPS - 1) {
                        inTrans = true; tProg = 0; holdT = 0;
                    } else if (curStep === STEPS - 1 && holdT >= HOLD_MS * 2.5) {
                        curStep = 0; holdT = 0; inTrans = false; tProg = 0;
                    }
                } else {
                    tProg += (dt * speed) / TRANS_MS;
                    if (tProg >= 1) {
                        tProg = 0; curStep++; inTrans = false; holdT = 0;
                    }
                }
            }

            ctx.clearRect(0, 0, CW, CH);
            drawHeader();
            drawLinks();

            const resident = Array.from({ length: N }, () => []);
            if (!inTrans) {
                for (let r = 0; r < N; r++)
                    for (let c = 0; c < N; c++)
                        resident[st[curStep][r][c]].push({ r, c });
            } else {
                for (let r = 0; r < N; r++)
                    for (let c = 0; c < N; c++) {
                        const fr = st[curStep][r][c], to = st[curStep + 1][r][c];
                        if (fr === to) resident[fr].push({ r, c });
                    }
            }

            for (let i = 0; i < N; i++) drawTPU(i, resident[i]);
            if (inTrans) drawFlying();


            requestAnimationFrame(tick);
        }

        // ─── Controls ───
        const pb = document.getElementById('allToAllBalancedPlayBtn');
        pb.onclick = () => {
            playing = !playing;
            pb.textContent = playing ? '⏸ Pause' : '▶ Play';
            pb.classList.toggle('active', playing);
        };

        document.getElementById('allToAllBalancedResetBtn').onclick = () => {
            curStep = 0; tProg = 0; inTrans = false; holdT = 0;
            playing = true; pb.textContent = '⏸ Pause'; pb.classList.add('active');
        };

        requestAnimationFrame(tick);
    })();
</script>
